<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Interactive Edge Process Viewer</title>
<style>
  body { font-family: Arial, sans-serif; background: #222; color: #eee; text-align: center; }
  #container {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin-top: 20px;
  }
  canvas { border: 1px solid #555; }
  #houghCanvas { cursor: crosshair; }
  #houghCanvas.drawing { cursor: none; }
  #controls { margin: 10px auto; width: 600px; }
  #stepLabel { font-weight: bold; }
  #houghControls {
    margin: 15px auto;
    padding: 15px;
    background: #333;
    border-radius: 8px;
    width: 600px;
  }
  #drawingTools {
    display: flex;
    gap: 10px;
    align-items: center;
    justify-content: center;
    margin: 10px 0;
  }
  .tool-group {
    display: flex;
    gap: 5px;
    align-items: center;
  }
  button {
    padding: 8px 16px;
    background: #4a90e2;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
  }
  button:hover { background: #357abd; }
  button:disabled { background: #666; cursor: not-allowed; }
  button.active { background: #e74c3c; }
  input[type="range"] { width: 80px; }
  #similarity { margin-top: 10px; }
  #matchInfo {
    background: #333;
    padding: 10px;
    border-radius: 5px;
    margin-top: 10px;
    min-height: 20px;
  }
  #loadingStatus {
    background: #444;
    padding: 10px;
    border-radius: 5px;
    margin-top: 10px;
    font-size: 14px;
  }
</style>
</head>
<body>

<h1>Interactive Edge Process Viewer</h1>

<div id="container">
  <canvas id="canvas" width="512" height="512"></canvas>
  <canvas id="houghCanvas" width="512" height="512"></canvas>
</div>

<div id="controls">
  <button id="randomBtn">Random Image</button>
  <br/><br/>
  <input type="range" id="stepSlider" min="0" max="5" value="0" />
  <div id="stepLabel">Step: original</div>
</div>

<div id="houghControls">
  <h3>Interactive Hough Space</h3>
  <div id="drawingTools">
    <div class="tool-group">
      <button id="toggleDraw">Enable Drawing</button>
      <button id="clearHough">Clear Drawing</button>
    </div>
    <div class="tool-group">
      <label>Brush Size:</label>
      <input type="range" id="brushSize" min="1" max="20" value="5" />
      <span id="brushSizeLabel">5</span>
    </div>
    <div class="tool-group">
      <label>Intensity:</label>
      <input type="range" id="brushIntensity" min="10" max="255" value="128" />
      <span id="brushIntensityLabel">128</span>
    </div>
  </div>
  <button id="findSimilar">Find Most Similar Image</button>
  <div id="loadingStatus">Loading JSON files...</div>
  <div id="matchInfo">Draw on the Hough space and click "Find Most Similar Image" to search</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>

<script>
// Processing steps labels:
const PROCESSING_STEPS = [
  'original',
  'grayscale',
  'gradient_magnitude',
  'nonmaxima',
  'hysteresis',
  'canny_downscaled'
];

// Canvas and contexts
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const width = canvas.width;
const height = canvas.height;

const houghCanvas = document.getElementById('houghCanvas');
const houghCtx = houghCanvas.getContext('2d');

// Controls
const stepSlider = document.getElementById('stepSlider');
const stepLabel = document.getElementById('stepLabel');
const randomBtn = document.getElementById('randomBtn');

// Hough controls
const toggleDrawBtn = document.getElementById('toggleDraw');
const clearHoughBtn = document.getElementById('clearHough');
const brushSizeSlider = document.getElementById('brushSize');
const brushSizeLabel = document.getElementById('brushSizeLabel');
const brushIntensitySlider = document.getElementById('brushIntensity');
const brushIntensityLabel = document.getElementById('brushIntensityLabel');
const findSimilarBtn = document.getElementById('findSimilar');
const matchInfo = document.getElementById('matchInfo');
const loadingStatus = document.getElementById('loadingStatus');

// State variables
let dataKeys = [];
let allData = {};
let currentKey = null;
let loadedJsonFiles = [];
let totalImagesLoaded = 0;
let originalImg = null;
let edgesDownscaledImgData = null;

let grayImageData = null;
let gradientMagnitudeData = null;
let nonmaxSuppressionData = null;
let hysteresisData = null;

let houghImgData = null;
let originalHoughData = null; // Store original hough data
let userDrawnHoughData = null; // Store user drawn data
let isDrawing = false;
let drawingEnabled = false;

// Decode base64+gzip encoded array to Uint8Array
function decodeBase64Gzip(encoded) {
  const b64 = encoded.data;
  const binaryString = atob(b64);
  const len = binaryString.length;
  const bytes = new Uint8Array(len);
  for(let i=0; i<len; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return pako.inflate(bytes);
}

function decodeArrayToUint8ClampedArray(encoded) {
  const decompressed = decodeBase64Gzip(encoded);
  const [h, w] = encoded.shape;
  return {data: decompressed, width: w, height: h};
}

function toImageDataFromGray(grayArr, w, h) {
  const imgData = ctx.createImageData(w, h);
  for(let i=0; i<grayArr.length; i++) {
    const v = grayArr[i];
    imgData.data[i*4] = v;
    imgData.data[i*4+1] = v;
    imgData.data[i*4+2] = v;
    imgData.data[i*4+3] = 255;
  }
  return imgData;
}

// Image processing functions
function rgbToGrayscale(imageData) {
  const w = imageData.width;
  const h = imageData.height;
  const gray = new Uint8ClampedArray(w*h);
  const data = imageData.data;
  for(let i=0; i<w*h; i++) {
    const r = data[i*4];
    const g = data[i*4+1];
    const b = data[i*4+2];
    gray[i] = 0.299*r + 0.587*g + 0.114*b;
  }
  return gray;
}

function sobelFilter(gray, w, h) {
  const Kx = [-1,0,1, -2,0,2, -1,0,1];
  const Ky = [-1,-2,-1, 0,0,0, 1,2,1];

  const Ix = new Float32Array(w*h);
  const Iy = new Float32Array(w*h);

  for(let y=1; y<h-1; y++) {
    for(let x=1; x<w-1; x++) {
      let gx=0, gy=0;
      for(let ky=-1; ky<=1; ky++) {
        for(let kx=-1; kx<=1; kx++) {
          const px = x+kx;
          const py = y+ky;
          const val = gray[py*w + px];
          const idx = (ky+1)*3 + (kx+1);
          gx += val * Kx[idx];
          gy += val * Ky[idx];
        }
      }
      Ix[y*w + x] = gx;
      Iy[y*w + x] = gy;
    }
  }
  return {Ix, Iy};
}

function gradientMagnitude(Ix, Iy) {
  const len = Ix.length;
  const mag = new Uint8ClampedArray(len);
  for(let i=0; i<len; i++) {
    mag[i] = Math.min(255, Math.sqrt(Ix[i]*Ix[i] + Iy[i]*Iy[i]));
  }
  return mag;
}

function gradientAngle(Ix, Iy) {
  const len = Ix.length;
  const angle = new Float32Array(len);
  for(let i=0; i<len; i++) {
    angle[i] = Math.atan2(Iy[i], Ix[i]);
  }
  return angle;
}

function nonMaximaSuppression(mag, angle, w, h) {
  const suppressed = new Uint8ClampedArray(w*h);
  for(let y=1; y<h-1; y++) {
    for(let x=1; x<w-1; x++) {
      const i = y*w + x;
      const theta = angle[i] * 180 / Math.PI;
      let direction = ((theta < 0) ? theta + 180 : theta);
      let neighbor1=0, neighbor2=0;

      if ((direction >= 0 && direction < 22.5) || (direction >= 157.5 && direction <= 180)) {
        neighbor1 = mag[i-1];
        neighbor2 = mag[i+1];
      } else if (direction >= 22.5 && direction < 67.5) {
        neighbor1 = mag[i - w + 1];
        neighbor2 = mag[i + w - 1];
      } else if (direction >= 67.5 && direction < 112.5) {
        neighbor1 = mag[i - w];
        neighbor2 = mag[i + w];
      } else if (direction >= 112.5 && direction < 157.5) {
        neighbor1 = mag[i - w - 1];
        neighbor2 = mag[i + w + 1];
      }

      if (mag[i] >= neighbor1 && mag[i] >= neighbor2) {
        suppressed[i] = mag[i];
      } else {
        suppressed[i] = 0;
      }
    }
  }
  return suppressed;
}

function hysteresisThreshold(suppressed, w, h, lowRatio=0.04, highRatio=0.16) {
  const highThresh = 255 * highRatio;
  const lowThresh = 255 * lowRatio;

  const strong = 255, weak = 75;
  const result = new Uint8ClampedArray(w*h);

  for(let i=0; i<w*h; i++) {
    if(suppressed[i] >= highThresh) result[i] = strong;
    else if(suppressed[i] >= lowThresh) result[i] = weak;
    else result[i] = 0;
  }

  function isStrongNeighbor(x,y) {
    for(let j=-1; j<=1; j++) {
      for(let i=-1; i<=1; i++) {
        if(i===0 && j===0) continue;
        let nx = x+i, ny = y+j;
        if(nx >= 0 && nx < w && ny >= 0 && ny < h) {
          if(result[ny*w + nx] === strong) return true;
        }
      }
    }
    return false;
  }

  let changed = true;
  while(changed) {
    changed = false;
    for(let y=1; y<h-1; y++) {
      for(let x=1; x<w-1; x++) {
        let i = y*w + x;
        if(result[i] === weak && isStrongNeighbor(x,y)) {
          result[i] = strong;
          changed = true;
        }
      }
    }
  }

  for(let i=0; i<w*h; i++) {
    if(result[i] !== strong) result[i] = 0;
  }

  return result;
}

// Hough drawing functions
function initializeUserDrawnHough() {
  if (originalHoughData) {
    const w = originalHoughData.width;
    const h = originalHoughData.height;
    userDrawnHoughData = ctx.createImageData(w, h);
    // Initialize with zeros (black)
    for(let i = 0; i < userDrawnHoughData.data.length; i += 4) {
      userDrawnHoughData.data[i] = 0;     // R
      userDrawnHoughData.data[i+1] = 0;   // G
      userDrawnHoughData.data[i+2] = 0;   // B
      userDrawnHoughData.data[i+3] = 255; // A
    }
  }
}

function drawOnHough(x, y) {
  if (!userDrawnHoughData || !originalHoughData) return;
  
  const brushSize = parseInt(brushSizeSlider.value);
  const intensity = parseInt(brushIntensitySlider.value);
  
  // Scale coordinates from canvas size to actual hough data size
  const scaleX = originalHoughData.width / width;
  const scaleY = originalHoughData.height / height;
  const houghX = Math.floor(x * scaleX);
  const houghY = Math.floor(y * scaleY);
  
  const w = userDrawnHoughData.width;
  const h = userDrawnHoughData.height;
  
  // Draw a circle
  for(let dy = -brushSize; dy <= brushSize; dy++) {
    for(let dx = -brushSize; dx <= brushSize; dx++) {
      if(dx*dx + dy*dy <= brushSize*brushSize) {
        const nx = houghX + dx;
        const ny = houghY + dy;
        if(nx >= 0 && nx < w && ny >= 0 && ny < h) {
          const idx = (ny * w + nx) * 4;
          userDrawnHoughData.data[idx] = intensity;     // R
          userDrawnHoughData.data[idx+1] = intensity;   // G
          userDrawnHoughData.data[idx+2] = intensity;   // B
        }
      }
    }
  }
  
  redrawHoughCanvas();
}

function redrawHoughCanvas() {
  houghCtx.clearRect(0, 0, width, height);
  
  // Draw original hough data first
  if(originalHoughData) {
    const offscreen = document.createElement('canvas');
    offscreen.width = originalHoughData.width;
    offscreen.height = originalHoughData.height;
    const offCtx = offscreen.getContext('2d');
    offCtx.putImageData(originalHoughData, 0, 0);

    houghCtx.imageSmoothingEnabled = false;
    houghCtx.drawImage(offscreen, 0, 0, width, height);
    houghCtx.imageSmoothingEnabled = true;
  }
  
  // Overlay user drawing if drawing is enabled
  if(drawingEnabled && userDrawnHoughData) {
    const offscreen2 = document.createElement('canvas');
    offscreen2.width = userDrawnHoughData.width;
    offscreen2.height = userDrawnHoughData.height;
    const offCtx2 = offscreen2.getContext('2d');
    offCtx2.putImageData(userDrawnHoughData, 0, 0);

    houghCtx.globalCompositeOperation = 'screen'; // Additive blending
    houghCtx.imageSmoothingEnabled = false;
    houghCtx.drawImage(offscreen2, 0, 0, width, height);
    houghCtx.imageSmoothingEnabled = true;
    houghCtx.globalCompositeOperation = 'source-over'; // Reset
  }
}

// Similarity calculation
function calculateSimilarity(houghData1, houghData2) {
  if (!houghData1 || !houghData2) return 0;
  if (houghData1.width !== houghData2.width || houghData1.height !== houghData2.height) return 0;
  
  let sumSquaredDiff = 0;
  let sumSquared1 = 0;
  let sumSquared2 = 0;
  
  const len = houghData1.data.length;
  for(let i = 0; i < len; i += 4) {
    const val1 = houghData1.data[i]; // Use R channel
    const val2 = houghData2.data[i];
    
    sumSquaredDiff += (val1 - val2) * (val1 - val2);
    sumSquared1 += val1 * val1;
    sumSquared2 += val2 * val2;
  }
  
  // Normalized cross-correlation
  const denom = Math.sqrt(sumSquared1 * sumSquared2);
  if (denom === 0) return 0;
  
  const mse = sumSquaredDiff / (len / 4);
  const maxVal = 255;
  const similarity = 1 - (mse / (maxVal * maxVal));
  
  return Math.max(0, similarity);
}

function findMostSimilarImage() {
  if (!userDrawnHoughData) {
    matchInfo.textContent = "No drawing to compare. Please draw on the Hough space first.";
    return;
  }
  
  if(dataKeys.length === 0) {
    matchInfo.textContent = "No images loaded yet. Please wait for loading to complete.";
    return;
  }
  
  let bestMatch = null;
  let bestSimilarity = -1;
  let totalImages = dataKeys.length;
  let processedImages = 0;
  
  matchInfo.innerHTML = `
    <strong>Searching...</strong><br>
    Progress: 0/${totalImages} images<br>
    Best match so far: none
  `;
  
  // Process images in chunks to avoid blocking UI
  const processChunk = (startIdx, chunkSize = 50) => {
    const endIdx = Math.min(startIdx + chunkSize, totalImages);
    
    for(let i = startIdx; i < endIdx; i++) {
      const key = dataKeys[i];
      const entry = allData[key];
      processedImages++;
      
      if(entry.hough_sinusoids) {
        const decoded = decodeArrayToUint8ClampedArray(entry.hough_sinusoids);
        const houghData = toImageDataFromGray(decoded.data, decoded.width, decoded.height);
        
        const similarity = calculateSimilarity(userDrawnHoughData, houghData);
        
        if(similarity > bestSimilarity) {
          bestSimilarity = similarity;
          bestMatch = key;
          
          // Update progress with current best match
          matchInfo.innerHTML = `
            <strong>Searching...</strong><br>
            Progress: ${processedImages}/${totalImages} images<br>
            Best match: ${bestMatch}<br>
            Similarity: ${(bestSimilarity * 100).toFixed(2)}%
          `;
        }
      }
    }
    
    if(endIdx < totalImages) {
      // Continue processing next chunk
      setTimeout(() => processChunk(endIdx, chunkSize), 10);
    } else {
      // Search complete
      if(bestMatch) {
        matchInfo.innerHTML = `
          <strong>✓ Search Complete!</strong><br>
          <strong>Best Match:</strong> ${bestMatch}<br>
          <strong>Similarity:</strong> ${(bestSimilarity * 100).toFixed(2)}%<br>
          <strong>Searched:</strong> ${totalImages} images across ${loadedJsonFiles.length} files
        `;
        
        // Load the best match image
        currentKey = bestMatch;
        const entry = allData[currentKey];
        
        originalImg = new Image();
        originalImg.crossOrigin = "Anonymous";
        originalImg.onload = () => {
          drawStep(parseInt(stepSlider.value));
          processImageSteps();
          
          // Update original hough data
          if(entry.hough_sinusoids) {
            const decoded = decodeArrayToUint8ClampedArray(entry.hough_sinusoids);
            originalHoughData = toImageDataFromGray(decoded.data, decoded.width, decoded.height);
          }
          redrawHoughCanvas();
        };
        originalImg.src = entry.path;
        
      } else {
        matchInfo.innerHTML = `
          <strong>No matches found</strong><br>
          Searched ${totalImages} images<br>
          Try drawing different patterns
        `;
      }
    }
  };
  
  // Start processing
  processChunk(0);
}

// Main loading and processing functions
async function discoverJsonFiles() {
  // Try to discover JSON files by attempting to load common patterns
  const possibleFiles = [];
  const folderPath = 'json_minimal_edges_base64/';
  
  // Common art movement names that might be in your dataset
  const commonNames = [
    'Abstract_Expressionism',
    'Art_Nouveau_Modern',
    'Baroque',
    'Cubism',
    'Expressionism',
    'Fauvism',
    'Impressionism',
    'Minimalism',
    'Pop_Art',
    'Post_Impressionism',
    'Realism',
    'Renaissance',
    'Romanticism',
    'Surrealism',
    'Symbolism'
  ];
  
  // Try different part numbers for each style
  for(const name of commonNames) {
    for(let part = 1; part <= 5; part++) {
      possibleFiles.push(`${folderPath}${name}_part${part}.json`);
    }
  }
  
  return possibleFiles;
}

async function loadAllJsonFiles() {
  loadingStatus.textContent = "Discovering JSON files...";
  
  const possibleFiles = await discoverJsonFiles();
  let loadedCount = 0;
  let totalImages = 0;
  
  for(const filePath of possibleFiles) {
    try {
      loadingStatus.textContent = `Loading ${filePath}... (${loadedCount} files loaded, ${totalImages} images)`;
      
      const response = await fetch(filePath);
      if(response.ok) {
        const data = await response.json();
        const imageCount = Object.keys(data).length;
        
        // Merge data into allData
        Object.assign(allData, data);
        
        loadedJsonFiles.push(filePath);
        loadedCount++;
        totalImages += imageCount;
        
        console.log(`✓ Loaded ${filePath}: ${imageCount} images`);
        
        // Update status with current progress
        loadingStatus.innerHTML = `
          <strong>Progress:</strong> ${loadedCount} files loaded<br>
          <strong>Total Images:</strong> ${totalImages}<br>
          <strong>Latest:</strong> ${filePath.split('/').pop()} (${imageCount} images)
        `;
        
        // Allow UI to update
        await new Promise(resolve => setTimeout(resolve, 50));
      }
    } catch(err) {
      // Silently skip files that don't exist or can't be loaded
      console.log(`Skipped ${filePath}: ${err.message}`);
    }
  }
  
  dataKeys = Object.keys(allData);
  
  if(totalImages > 0) {
    loadingStatus.innerHTML = `
      <strong>✓ Loading Complete!</strong><br>
      <strong>Files Loaded:</strong> ${loadedCount}<br>
      <strong>Total Images:</strong> ${totalImages}<br>
      <strong>Ready for similarity search</strong>
    `;
    
    console.log(`Successfully loaded ${loadedCount} JSON files with ${totalImages} total images`);
    console.log('Loaded files:', loadedJsonFiles.map(f => f.split('/').pop()));
    
    // Load first random image
    loadRandomImage();
  } else {
    loadingStatus.innerHTML = `
      <strong>⚠️ No JSON files found</strong><br>
      Please ensure JSON files are in the json_minimal_edges_base64/ folder<br>
      Expected format: StyleName_part1.json, StyleName_part2.json, etc.
    `;
  }
}

async function loadData() {
  await loadAllJsonFiles();
}

function loadRandomImage() {
  if(dataKeys.length === 0) {
    console.warn("No images available to load");
    return;
  }
  
  currentKey = dataKeys[Math.floor(Math.random() * dataKeys.length)];
  const entry = allData[currentKey];

  stepSlider.value = 0;
  stepLabel.textContent = 'Step: original';

  originalImg = new Image();
  originalImg.crossOrigin = "Anonymous";
  originalImg.onload = () => {
    drawStep(0);
    processImageSteps();
    drawHough();
  };
  originalImg.onerror = () => {
    console.warn("Failed to load original image.");
    ctx.clearRect(0,0,width,height);
    houghCtx.clearRect(0,0,width,height);
  };
  originalImg.src = entry.path;

  // Decode edges_downscaled
  const decoded = decodeArrayToUint8ClampedArray(entry.edges_downscaled);
  edgesDownscaledImgData = toImageDataFromGray(decoded.data, decoded.width, decoded.height);

  // Decode hough sinusoids and store original
  if(entry.hough_sinusoids) {
    const houghDecoded = decodeArrayToUint8ClampedArray(entry.hough_sinusoids);
    houghImgData = toImageDataFromGray(houghDecoded.data, houghDecoded.width, houghDecoded.height);
    originalHoughData = houghImgData;
    initializeUserDrawnHough();
  } else {
    houghImgData = null;
    originalHoughData = null;
  }
  
  matchInfo.innerHTML = `
    <strong>Current Image:</strong> ${currentKey}<br>
    <strong>Dataset Size:</strong> ${dataKeys.length} images<br>
    Draw on the Hough space and click 'Find Most Similar Image' to search.
  `;
}

function processImageSteps() {
  ctx.clearRect(0,0,width,height);
  ctx.drawImage(originalImg, 0, 0, width, height);
  const imgData = ctx.getImageData(0, 0, width, height);
  const gray = rgbToGrayscale(imgData);
  grayImageData = toImageDataFromGray(gray, width, height);

  const {Ix, Iy} = sobelFilter(gray, width, height);
  const gradMag = gradientMagnitude(Ix, Iy);
  const gradAng = gradientAngle(Ix, Iy);
  gradientMagnitudeData = toImageDataFromGray(gradMag, width, height);

  const nms = nonMaximaSuppression(gradMag, gradAng, width, height);
  nonmaxSuppressionData = toImageDataFromGray(nms, width, height);

  const hyst = hysteresisThreshold(nms, width, height);
  hysteresisData = toImageDataFromGray(hyst, width, height);
}

function drawHough() {
  redrawHoughCanvas();
}

function drawStep(stepIdx) {
  ctx.clearRect(0, 0, width, height);
  switch(PROCESSING_STEPS[stepIdx]) {
    case 'original':
      if(originalImg && originalImg.complete) {
        ctx.drawImage(originalImg, 0, 0, width, height);
      }
      break;
    case 'grayscale':
      if(grayImageData) {
        ctx.putImageData(grayImageData, 0, 0);
      }
      break;
    case 'gradient_magnitude':
      if(gradientMagnitudeData) {
        ctx.putImageData(gradientMagnitudeData, 0, 0);
      }
      break;
    case 'nonmaxima':
      if(nonmaxSuppressionData) {
        ctx.putImageData(nonmaxSuppressionData, 0, 0);
      }
      break;
    case 'hysteresis':
      if(hysteresisData) {
        ctx.putImageData(hysteresisData, 0, 0);
      }
      break;
    case 'canny_downscaled':
      if(edgesDownscaledImgData) {
        const offscreen = document.createElement('canvas');
        offscreen.width = edgesDownscaledImgData.width;
        offscreen.height = edgesDownscaledImgData.height;
        const offCtx = offscreen.getContext('2d');
        offCtx.putImageData(edgesDownscaledImgData, 0, 0);

        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(offscreen, 0, 0, width, height);
        ctx.imageSmoothingEnabled = true;
      }
      break;
  }
}

// Event listeners
stepSlider.addEventListener('input', e => {
  const val = parseInt(e.target.value);
  stepLabel.textContent = `Step: ${PROCESSING_STEPS[val]}`;
  drawStep(val);
});

randomBtn.addEventListener('click', () => {
  loadRandomImage();
});

// Hough interaction events
toggleDrawBtn.addEventListener('click', () => {
  drawingEnabled = !drawingEnabled;
  if(drawingEnabled) {
    toggleDrawBtn.textContent = 'Disable Drawing';
    toggleDrawBtn.classList.add('active');
    houghCanvas.classList.add('drawing');
    initializeUserDrawnHough();
  } else {
    toggleDrawBtn.textContent = 'Enable Drawing';
    toggleDrawBtn.classList.remove('active');
    houghCanvas.classList.remove('drawing');
  }
  redrawHoughCanvas();
});

clearHoughBtn.addEventListener('click', () => {
  initializeUserDrawnHough();
  redrawHoughCanvas();
  matchInfo.textContent = "Drawing cleared. Draw on the Hough space and click 'Find Most Similar Image' to search.";
});

brushSizeSlider.addEventListener('input', e => {
  brushSizeLabel.textContent = e.target.value;
});

brushIntensitySlider.addEventListener('input', e => {
  brushIntensityLabel.textContent = e.target.value;
});

findSimilarBtn.addEventListener('click', findMostSimilarImage);

// Mouse events for drawing
houghCanvas.addEventListener('mousedown', e => {
  if(!drawingEnabled) return;
  isDrawing = true;
  const rect = houghCanvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  drawOnHough(x, y);
});

houghCanvas.addEventListener('mousemove', e => {
  if(!drawingEnabled || !isDrawing) return;
  const rect = houghCanvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  drawOnHough(x, y);
});

houghCanvas.addEventListener('mouseup', () => {
  isDrawing = false;
});

houghCanvas.addEventListener('mouseleave', () => {
  isDrawing = false;
});

// Initialize
loadData();

</script>
</body>
</html>