<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Interactive Edge Process Viewer</title>
    <style>
    /* Root Variables */
    :root {
        --bg-color: #1e1e2e;
        --card-bg: #2a2a3e;
        --accent: #7f5af0;
        --accent-hover: #6d4de0;
        --text: #e0def4;
        --subtext: #a6adc8;
        --border: #3e3e5e;
        --radius: 10px;
        --transition: 0.2s;
    }

    /* Reset & Base */
    *, *::before, *::after {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
    }
    body {
        font-family: 'Segoe UI', Tahoma, sans-serif;
        background: var(--bg-color);
        color: var(--text);
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
        padding: 20px;
    }
    h1 {
        font-size: 2rem;
        margin-bottom: 10px;
        text-transform: uppercase;
        letter-spacing: 2px;
    }

    /* Layout */
    #container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin: 20px 0;
    }

    /* Preview stack */
    #previewContainer {
        position: relative;
        width: 512px;
        height: 512px;
    }

    /* Main canvases */
    #canvas,
    #houghCanvas {
        border: 2px solid var(--border);
        border-radius: var(--radius);
        background: var(--card-bg);
        cursor: crosshair;
        display: block;
    }

    /* Overlay canvas */
    #previewOverlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 512px;
        height: 512px;
        pointer-events: none;
        z-index: 2;
        background: transparent;
    }

    /* Ensure base canvas is underneath */
    #canvas {
        position: relative;
        z-index: 1;
    }

    /* Controls Panel */
    .panel,
    #controls, /* if you didn't wrap controls in .panel */
    #houghControls {
        background: var(--card-bg);
        border: 1px solid var(--border);
        border-radius: var(--radius);
        padding: 15px;
        margin-bottom: 20px;
        width: 600px;
        color: var(--text);
    }
    .panel h3 {
        margin-bottom: 10px;
        color: var(--accent);
    }

    /* Add these styles to your existing CSS */
.app-controls {
  width: 100%;
  max-width: 1050px;
  margin: 0 auto;
}

.control-panel {
  background: var(--card-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 20px;
  margin-bottom: 20px;
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

.panel-section {
  flex: 1;
  min-width: 300px;
  background: rgba(0,0,0,0.15);
  border-radius: var(--radius);
  padding: 15px;
  border-left: 3px solid var(--accent);
}

.panel-section h3 {
  color: var(--accent);
  margin-top: 0;
  margin-bottom: 15px;
  font-size: 1rem;
  border-bottom: 1px solid var(--border);
  padding-bottom: 8px;
}

.btn-group {
  display: flex;
  gap: 10px;
  margin-bottom: 15px;
  flex-wrap: wrap;
}

/* Button styles with visual feedback */
.primary-btn, .action-btn, .danger-btn, .secondary-btn {
  padding: 8px 12px;
  border: none;
  border-radius: var(--radius);
  font-size: 0.9rem;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  gap: 6px;
  flex: 1;
  justify-content: center;
}

.primary-btn {
  background: var(--accent);
  color: white;
}

.primary-btn:hover:not(:disabled) {
  background: var(--accent-hover);
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

.action-btn {
  background: #2c6aa1;
  color: white;
}

.action-btn:hover:not(:disabled) {
  background: #3579b5;
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

.danger-btn {
  background: #a13c3c;
  color: white;
}

.danger-btn:hover:not(:disabled) {
  background: #bd4444;
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

.secondary-btn {
  background: rgba(127, 90, 240, 0.2);
  color: var(--text);
}

.secondary-btn:hover:not(:disabled) {
  background: rgba(127, 90, 240, 0.3);
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

button:active {
  transform: translateY(0) !important;
  box-shadow: none !important;
}

button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  transform: none !important;
  box-shadow: none !important;
}

button.active {
  background: #f43f5e;
  box-shadow: inset 0 0 5px rgba(0,0,0,0.3);
}

.icon {
  font-style: normal;
  font-size: 1.1em;
}

/* Tool settings */
.tool-settings {
  background: rgba(0,0,0,0.2);
  border-radius: var(--radius);
  padding: 12px;
}

.slider-container {
  margin: 15px 0;
}

.slider-group {
  display: flex;
  align-items: center;
  gap: 10px;
  margin: 10px 0;
}

.slider-group label {
  flex: 0 0 80px;
  color: var(--subtext);
  font-size: 0.9rem;
}

/* Visual indicators */
.badge {
  display: inline-block;
  background: var(--accent);
  color: white;
  padding: 3px 8px;
  border-radius: 12px;
  font-size: 0.8rem;
  margin-top: 5px;
}

.value-badge {
  display: inline-block;
  background: rgba(127, 90, 240, 0.2);
  color: var(--text);
  padding: 2px 8px;
  border-radius: 10px;
  font-size: 0.8rem;
  min-width: 30px;
  text-align: center;
}

/* Status panels */
.status-panel {
  background: var(--bg-color);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 12px 15px;
  margin-top: 10px;
  font-size: 0.9rem;
}

.results-panel {
  background: var(--card-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 15px;
  margin-top: 15px;
  font-size: 0.9rem;
  max-height: 200px;
  overflow-y: auto;
}

/* Better canvas indicators */
#canvas.drawing {
  cursor: crosshair;
  box-shadow: 0 0 0 2px #e64c65;
}

#houghCanvas.drawing {
  cursor: crosshair;
  box-shadow: 0 0 0 2px #e64c65;
}

.mode-indicator {
  position: fixed;
  top: 20px;
  right: 20px;
  background: rgba(42, 42, 62, 0.9);
  color: white;
  padding: 8px 12px;
  border-radius: var(--radius);
  font-size: 0.8rem;
  pointer-events: none;
  z-index: 100;
  box-shadow: 0 2px 10px rgba(0,0,0,0.3);
  opacity: 0;
  transition: opacity 0.3s ease;
}

.mode-indicator.visible {
  opacity: 1;
}

/* Responsive improvements */
@media (max-width: 768px) {
  .control-panel {
    flex-direction: column;
  }
  
  .btn-group {
    flex-direction: column;
  }
}

/* Modal overlay styles */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.8);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s ease;
}

.modal-overlay.active {
  opacity: 1;
  pointer-events: all;
}

.modal-content {
  background: var(--card-bg);
  border-radius: var(--radius);
  padding: 30px;
  max-width: 800px;
  max-height: 80vh;
  overflow-y: auto;
  width: 90%;
  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
  position: relative;
}

.modal-close {
  position: absolute;
  top: 15px;
  right: 15px;
  background: none;
  border: none;
  color: var(--subtext);
  font-size: 1.5rem;
  cursor: pointer;
  transition: color 0.2s;
}

.modal-close:hover {
  color: var(--text);
}

.modal-title {
  color: var(--accent);
  margin-bottom: 20px;
  font-size: 1.5rem;
}

.method-explanation {
  margin-bottom: 20px;
}

.method-explanation h3 {
  color: var(--accent);
  margin-top: 20px;
  margin-bottom: 10px;
}

.method-explanation p {
  margin-bottom: 10px;
  line-height: 1.6;
}

.method-explanation ul {
  margin-left: 20px;
  margin-bottom: 15px;
}

.method-explanation li {
  margin-bottom: 8px;
}

.method-explanation code {
  background: rgba(0, 0, 0, 0.3);
  padding: 2px 5px;
  border-radius: 3px;
  font-family: monospace;
}

.about-btn {
  margin-top: 20px;
  background: var(--accent);
  color: white;
  border: none;
  padding: 10px 15px;
  border-radius: var(--radius);
  cursor: pointer;
  transition: background 0.2s;
  display: flex;
  align-items: center;
  gap: 8px;
}

.about-btn:hover {
  background: var(--accent-hover);
}

    </style>

</head>
<body>

  <h1>Interactive Edge Process Viewer</h1>

  <div id="container">
    <div id="previewContainer">
      <canvas id="canvas" width="512" height="512"></canvas>
      <canvas id="previewOverlay" width="512" height="512"></canvas>
    </div>
    <canvas id="houghCanvas" width="512" height="512"></canvas>
  </div>

  <div class="app-controls">
    <div class="control-panel">
      <div class="panel-section">
        <h3>Image Controls</h3>
        <button id="randomBtn" class="primary-btn">
          <span class="icon">üñºÔ∏è</span> Random Image
        </button>
        
        <div class="slider-container">
          <label for="stepSlider">Processing Step:</label>
          <input type="range" id="stepSlider" min="0" max="5" value="0" />
          <div id="stepLabel" class="badge">Step: original</div>
        </div>
      </div>

      <div class="panel-section">
        <h3>Drawing Tools</h3>
        <div class="btn-group">
          <button id="toggleDraw" class="action-btn" title="Turn drawing on/off">
            <span class="icon">‚úèÔ∏è</span> Enable Drawing
          </button>
          <button id="toggleDrawMode" class="action-btn" title="Switch between drawing on Hough or Image">
            <span class="icon">üîÑ</span> Draw on Hough
          </button>
          <button id="clearHough" class="danger-btn" title="Clear your drawing">
            <span class="icon">üóëÔ∏è</span> Clear Drawing
          </button>
        </div>

        <div class="tool-settings">
          <div class="slider-group">
            <label for="brushSize">Brush Size:</label>
            <input type="range" id="brushSize" min="1" max="20" value="5" />
            <span id="brushSizeLabel" class="value-badge">5</span>
          </div>
          
          <div class="slider-group">
            <label for="brushIntensity">Intensity:</label>
            <input type="range" id="brushIntensity" min="10" max="255" value="128" />
            <span id="brushIntensityLabel" class="value-badge">128</span>
          </div>
        </div>
      </div>

      <div class="panel-section">
        <h3>Analysis</h3>
        <div class="btn-group">
          <button id="findSimilar" class="primary-btn" title="Search for similar images">
            <span class="icon">üîç</span> Find Similar Images
          </button>
          <button id="showPreview" class="secondary-btn" title="Preview detected edges">
            <span class="icon">üëÅÔ∏è</span> Show Edge Preview
          </button>
          <button id="showDetectedLines" class="action-btn" title="Show detected lines from Hough peaks">
            <span class="icon">üìè</span> Show Detected Lines
          </button>
        </div>
      </div>
    </div>

    <div id="active-mode" class="mode-indicator">Drawing: <span id="draw-mode">Hough Space</span></div>
    <div id="loadingStatus" class="status-panel">Loading JSON files...</div>
    <div id="matchInfo" class="results-panel">Draw on the Hough space and click 'Find Similar Images' to search</div>
    
    <!-- About Methods Button -->
    <button id="aboutMethodsBtn" class="about-btn">
      <span class="icon">‚ÑπÔ∏è</span> About the Methods
    </button>
  </div>

  <!-- Modal Overlay -->
  <div id="methodsModal" class="modal-overlay">
    <div class="modal-content">
      <button class="modal-close">&times;</button>
      <h2 class="modal-title">Edge Detection and Hough Transform Methods</h2>
      
      <div class="method-explanation">
        <h3>Canny Edge Detection</h3>
        <p>The Canny edge detector is a multi-stage algorithm that identifies edges in images:</p>
        <ol>
          <li><strong>Grayscale Conversion:</strong> Convert the image to grayscale for simpler processing.</li>
          <li><strong>Gradient Calculation:</strong> Compute intensity gradients using Sobel filters to find edge strength and direction.</li>
          <li><strong>Non-Maximum Suppression:</strong> Thin edges by keeping only local maxima in the gradient direction.</li>
          <li><strong>Edge Tracking:</strong> Classify edge pixels as strong, weak, or non-edges using high/low thresholds. Final edges are determined by hysteresis, connecting weak edges to strong ones.</li>
        </ol>
      </div>
      
      <div class="method-explanation">
        <h3>Hough Transform</h3>
        <p>The Hough Transform is used to detect lines in an image:</p>
        <ul>
          <li>Each edge point in image space is transformed into a sinusoidal curve in Hough space (œÅ,Œ∏).</li>
          <li>Points where curves intersect in Hough space correspond to lines in the original image.</li>
          <li>The accumulator array counts votes for potential lines.</li>
          <li>Peaks in the accumulator indicate the most prominent lines.</li>
        </ul>
        <p>In this application, you can draw directly in Hough space to explore how different patterns correspond to lines in the image.</p>
      </div>
      
      <div class="method-explanation">
        <h3>Drawing on Image & Conversion to Hough Space</h3>
        <p>This application provides two ways to interact with the Hough transform:</p>
        
        <h4>1. Drawing Directly on the Image</h4>
        <ul>
          <li>When you draw on the image canvas, your strokes are treated as potential edges.</li>
          <li>The application performs a real-time Hough transform on your drawing:</li>
          <ol>
            <li>Each drawn pixel is considered as an edge point in image space.</li>
            <li>For each point, we calculate all possible lines that could pass through it.</li>
            <li>These lines are mapped to sinusoidal curves in Hough space (œÅ,Œ∏ coordinates).</li>
            <li>The intensity of your drawing affects how strongly these curves are represented.</li>
          </ol>
          <li>This converted Hough space representation is then used for similarity searches.</li>
        </ul>
        
        <h4>2. Drawing in Hough Space</h4>
        <ul>
          <li>You can also draw directly in Hough space to explore how different patterns affect the image.</li>
          <li>Each point in Hough space corresponds to a specific line in the original image.</li>
          <li>Drawing bright spots in Hough space emphasizes certain line orientations.</li>
        </ul>
      </div>
      
      <div class="method-explanation">
        <h3>Edge Preview Functionality</h3>
        <p>The "Show Edge Preview" feature visualizes how your Hough space drawing would appear as actual edges in the image:</p>
        <ul>
          <li><strong>Inverse Hough Transform:</strong> The preview performs an inverse transform from Hough space back to image space.</li>
          <li><strong>Line Projection:</strong> For each significant point in Hough space, the corresponding line is drawn in the image.</li>
          <li><strong>Intensity Mapping:</strong> The brightness of points in Hough space determines the opacity of the projected lines.</li>
          <li><strong>Real-time Feedback:</strong> As you modify your Hough space drawing, the edge preview updates immediately.</li>
        </ul>
        <p>This feature helps you understand the relationship between Hough space patterns and the actual image edges they represent.</p>
      </div>
      
      <div class="method-explanation">
        <h3>Image Similarity Search</h3>
        <p>The application uses Hough space representations to find similar images:</p>
        <ul>
          <li>Each image's edge information is converted to a Hough space representation.</li>
          <li>When you draw in Hough space, the system compares your drawing to precomputed Hough transforms.</li>
          <li>Similarity is measured using distance metrics between Hough space patterns.</li>
          <li>The most similar images (based on edge structure) are returned as results.</li>
        </ul>
      </div>
      
      <div class="method-explanation">
        <h3>Interactive Features</h3>
        <p>Key interactive elements in this application:</p>
        <ul>
          <li><strong>Drawing Modes:</strong> Draw directly in Hough space or on the image (which gets converted to Hough space).</li>
          <li><strong>Edge Preview:</strong> Visualize how your Hough space drawing would appear as edges in the image.</li>
          <li><strong>Processing Steps:</strong> View each stage of the Canny edge detection pipeline.</li>
          <li><strong>Similarity Search:</strong> Find images with edge structures similar to your drawing.</li>
        </ul>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', function() {
    const PROCESSING_STEPS = [
      'original','grayscale','gradient_magnitude','nonmaxima','hysteresis','canny_downscaled'
    ];

    // Canvas setup
    const canvas = document.getElementById('canvas');
    const ctx    = canvas.getContext('2d');
    const width  = canvas.width, height = canvas.height;
    const houghCanvas = document.getElementById('houghCanvas');
    const houghCtx    = houghCanvas.getContext('2d');
    const previewOverlay = document.getElementById('previewOverlay');
    const previewCtx = previewOverlay.getContext('2d');

    // Controls
    const stepSlider   = document.getElementById('stepSlider');
    const stepLabel    = document.getElementById('stepLabel');
    const randomBtn    = document.getElementById('randomBtn');
    const toggleDrawBtn    = document.getElementById('toggleDraw');
    const clearHoughBtn    = document.getElementById('clearHough');
    const brushSizeSlider    = document.getElementById('brushSize');
    const brushSizeLabel     = document.getElementById('brushSizeLabel');
    const brushIntensitySlider = document.getElementById('brushIntensity');
    const brushIntensityLabel  = document.getElementById('brushIntensityLabel');
    const findSimilarBtn    = document.getElementById('findSimilar');
    const showPreviewBtn    = document.getElementById('showPreview');
    const matchInfo         = document.getElementById('matchInfo');
    const loadingStatus     = document.getElementById('loadingStatus');
    const toggleDrawModeBtn = document.getElementById('toggleDrawMode');
    const aboutMethodsBtn   = document.getElementById('aboutMethodsBtn');
    const methodsModal      = document.getElementById('methodsModal');
    const modalCloseBtn     = document.querySelector('.modal-close');
    const showDetectedLinesBtn = document.getElementById('showDetectedLines');
    

    // Data holders
    let dataKeys = [], allData = {}, currentKey = null;
    let originalImg, edgesDownscaledImgData, grayImageData,
        gradientMagnitudeData, nonmaxSuppressionData,
        hysteresisData, houghImgData, originalHoughData,
        userDrawnHoughData;
    let isDrawing = false, drawingEnabled = false, showPreview = false;
    let drawingMode = 'hough'; // 'hough' or 'image'
    let imageDrawData = null;
    let showDetectedLines = false;

    // --- Helper functions (decode, processing, drawing) ---
    function decodeBase64Gzip(encoded) {
      const b64 = encoded.data;
      const bin = atob(b64);
      const len = bin.length;
      const buf = new Uint8Array(len);
      for(let i=0;i<len;i++) buf[i]=bin.charCodeAt(i);
      return pako.inflate(buf);
    }

    function decodeArrayToUint8ClampedArray(encoded) {
      const data = decodeBase64Gzip(encoded);
      const [h,w] = encoded.shape;
      return { data, width:w, height:h };
    }

    function toImageDataFromGray(grayArr,w,h) {
      const img = ctx.createImageData(w,h);
      for(let i=0;i<grayArr.length;i++){
        const v=grayArr[i];
        img.data[i*4]=v;
        img.data[i*4+1]=v;
        img.data[i*4+2]=v;
        img.data[i*4+3]=255;
      }
      return img;
    }

    function rgbToGrayscale(imageData) {
      const w=imageData.width, h=imageData.height;
      const gray=new Uint8ClampedArray(w*h);
      const d=imageData.data;
      for(let i=0;i<w*h;i++){
        gray[i]=0.299*d[i*4]+0.587*d[i*4+1]+0.114*d[i*4+2];
      }
      return gray;
    }

    function sobelFilter(gray,w,h){
      const Kx=[-1,0,1,-2,0,2,-1,0,1], Ky=[-1,-2,-1,0,0,0,1,2,1];
      const Ix=new Float32Array(w*h), Iy=new Float32Array(w*h);
      for(let y=1;y<h-1;y++){
        for(let x=1;x<w-1;x++){
          let gx=0,gy=0;
          for(let ky=-1;ky<=1;ky++){
            for(let kx=-1;kx<=1;kx++){
              const px=x+kx, py=y+ky, val=gray[py*w+px];
              const idx=(ky+1)*3+(kx+1);
              gx+=val*Kx[idx]; gy+=val*Ky[idx];
            }
          }
          Ix[y*w+x]=gx; Iy[y*w+x]=gy;
        }
      }
      return {Ix,Iy};
    }

    function gradientMagnitude(Ix,Iy){
      const len=Ix.length, mag=new Uint8ClampedArray(len);
      for(let i=0;i<len;i++){
        mag[i]=Math.min(255,Math.sqrt(Ix[i]*Ix[i]+Iy[i]*Iy[i]));
      }
      return mag;
    }

    function gradientAngle(Ix,Iy){
      const len=Ix.length, angle=new Float32Array(len);
      for(let i=0;i<len;i++){
        angle[i]=Math.atan2(Iy[i],Ix[i]);
      }
      return angle;
    }

    function nonMaximaSuppression(mag,angle,w,h){
      const out=new Uint8ClampedArray(w*h);
      for(let y=1;y<h-1;y++){
        for(let x=1;x<w-1;x++){
          const i=y*w+x;
          let dir=(angle[i]*180/Math.PI+180)%180;
          let n1=0,n2=0;
          if((dir<22.5||dir>=157.5)){n1=mag[i-1];n2=mag[i+1];}
          else if(dir<67.5){n1=mag[i-w+1];n2=mag[i+w-1];}
          else if(dir<112.5){n1=mag[i-w];n2=mag[i+w];}
          else{n1=mag[i-w-1];n2=mag[i+w+1];}
          out[i]=(mag[i]>=n1&&mag[i]>=n2)?mag[i]:0;
        }
      }
      return out;
    }

    function hysteresisThreshold(sup,w,h,low=0.04,high=0.16){
      const ht=255*high, lt=255*low;
      const strong=255, weak=75;
      const res=new Uint8ClampedArray(w*h);
      for(let i=0;i<w*h;i++){
        if(sup[i]>=ht) res[i]=strong;
        else if(sup[i]>=lt) res[i]=weak;
      }
      function hasStrongNeighbor(x,y){
        for(let j=-1;j<=1;j++){
          for(let i=-1;i<=1;i++){
            if(i||j){
              const nx=x+i, ny=y+j;
              if(nx>=0&&nx<w&&ny>=0&&ny<h){
                if(res[ny*w+nx]===strong) return true;
              }
            }
          }
        }
        return false;
      }
      let changed=true;
      while(changed){
        changed=false;
        for(let y=1;y<h-1;y++){
          for(let x=1;x<w-1;x++){
            const idx=y*w+x;
            if(res[idx]===weak && hasStrongNeighbor(x,y)){
              res[idx]=strong; changed=true;
            }
          }
        }
      }
      for(let i=0;i<w*h;i++){
        if(res[i]!==strong) res[i]=0;
      }
      return res;
    }

    // --- Drawing & Hough ---
    function initializeUserDrawnHough(){
      if(!originalHoughData) return;
      const w=originalHoughData.width, h=originalHoughData.height;
      userDrawnHoughData=ctx.createImageData(w,h);
      for(let i=0;i<userDrawnHoughData.data.length;i+=4){
        userDrawnHoughData.data.set([0,0,0,255],i);
      }
    }

    function initializeImageDrawing() {
      imageDrawData = ctx.createImageData(width, height);
      // Fill with transparent pixels
      for(let i=0; i<imageDrawData.data.length; i+=4) {
        imageDrawData.data.set([0, 0, 0, 0], i);
      }
    }

    function redrawHoughCanvas(){
      houghCtx.clearRect(0,0,width,height);
      if(originalHoughData){
        const off=document.createElement('canvas');
        off.width=originalHoughData.width; off.height=originalHoughData.height;
        const offCtx=off.getContext('2d');
        offCtx.putImageData(originalHoughData,0,0);
        houghCtx.imageSmoothingEnabled=false;
        houghCtx.drawImage(off,0,0,width,height);
      }
      if(drawingEnabled && userDrawnHoughData){
        const off2=document.createElement('canvas');
        off2.width=userDrawnHoughData.width; off2.height=userDrawnHoughData.height;
        const offCtx2=off2.getContext('2d');
        offCtx2.putImageData(userDrawnHoughData,0,0);
        houghCtx.globalCompositeOperation='screen';
        houghCtx.imageSmoothingEnabled=false;
        houghCtx.drawImage(off2,0,0,width,height);
        houghCtx.globalCompositeOperation='source-over';
      }
      if (showDetectedLines) {
        setTimeout(() => drawDetectedLines(), 10);
      }
    }

    function drawOnHough(x,y){
      if(!drawingEnabled||!userDrawnHoughData) return;
      const bSize=parseInt(brushSizeSlider.value);
      const intensity=parseInt(brushIntensitySlider.value);
      const scaleX=userDrawnHoughData.width/width;
      const scaleY=userDrawnHoughData.height/height;
      const hx=Math.floor(x*scaleX), hy=Math.floor(y*scaleY);
      const w=userDrawnHoughData.width, h=userDrawnHoughData.height;
      for(let dy=-bSize;dy<=bSize;dy++){
        for(let dx=-bSize;dx<=bSize;dx++){
          if(dx*dx+dy*dy<=bSize*bSize){
            const nx=hx+dx, ny=hy+dy;
            if(nx>=0&&nx<w&&ny>=0&&ny<h){
              const idx=(ny*w+nx)*4;
              userDrawnHoughData.data[idx]=intensity;
              userDrawnHoughData.data[idx+1]=intensity;
              userDrawnHoughData.data[idx+2]=intensity;
              // alpha remains 255
            }
          }
        }
      }
      redrawHoughCanvas();
      if(showPreview) updateEdgePreview();
    }

    // Draw on image canvas
    function drawOnImage(x, y) {
      if(drawingMode !== 'image' || !imageDrawData) return;
      
      const bSize = parseInt(brushSizeSlider.value);
      const intensity = parseInt(brushIntensitySlider.value);
      
      // Draw a circle at cursor position
      for(let dy=-bSize; dy<=bSize; dy++) {
        for(let dx=-bSize; dx<=bSize; dx++) {
          if(dx*dx + dy*dy <= bSize*bSize) {
            const nx = Math.floor(x + dx);
            const ny = Math.floor(y + dy);
            if(nx >= 0 && nx < width && ny >= 0 && ny < height) {
              const idx = (ny * width + nx) * 4;
              imageDrawData.data[idx] = 255;       // Red
              imageDrawData.data[idx+1] = 255;     // Green
              imageDrawData.data[idx+2] = 255;     // Blue
              imageDrawData.data[idx+3] = intensity; // Alpha
            }
          }
        }
      }
      
      // Display drawn content
      previewCtx.putImageData(imageDrawData, 0, 0);
      
      // Convert to Hough space when drawing on image
      convertImageToHough();
    }

    // Function to convert drawn image to Hough space
    function convertImageToHough() {
      if(!userDrawnHoughData) initializeUserDrawnHough();
      
      // Clear previous Hough data
      for(let i=0; i<userDrawnHoughData.data.length; i+=4) {
        userDrawnHoughData.data.set([0, 0, 0, 255], i);
      }
      
      // Get dimensions
      const imgWidth = width;
      const imgHeight = height;
      const houghWidth = userDrawnHoughData.width;
      const houghHeight = userDrawnHoughData.height;
      
      // Hough transform parameters
      const maxDist = Math.sqrt(imgWidth*imgWidth + imgHeight*imgHeight) / 2;
      const dTheta = Math.PI / houghWidth;
      
      // For each pixel in the image
      for(let y=0; y<imgHeight; y++) {
        for(let x=0; x<imgWidth; x++) {
          // Check if this is an edge pixel (non-transparent)
          const imgIdx = (y * imgWidth + x) * 4;
          if(imageDrawData.data[imgIdx+3] > 20) {
            // For each theta value
            for(let thetaIdx=0; thetaIdx<houghWidth; thetaIdx++) {
              const theta = thetaIdx * dTheta;
              const cosTheta = Math.cos(theta);
              const sinTheta = Math.sin(theta);
              
              // Calculate rho = x*cos(theta) + y*sin(theta)
              const rho = x * cosTheta + y * sinTheta;
              
              // Map rho to [0, houghHeight)
              const rhoIdx = Math.floor(((rho + maxDist) / (2 * maxDist)) * houghHeight);
              
              if(rhoIdx >= 0 && rhoIdx < houghHeight) {
                // Accumulate in Hough space
                const houghIdx = (rhoIdx * houghWidth + thetaIdx) * 4;
                const intensity = imageDrawData.data[imgIdx+3]; // Use alpha as intensity
                userDrawnHoughData.data[houghIdx] = Math.min(255, userDrawnHoughData.data[houghIdx] + intensity/4);
                userDrawnHoughData.data[houghIdx+1] = Math.min(255, userDrawnHoughData.data[houghIdx+1] + intensity/4);
                userDrawnHoughData.data[houghIdx+2] = Math.min(255, userDrawnHoughData.data[houghIdx+2] + intensity/4);
              }
            }
          }
        }
      }
      
      redrawHoughCanvas();
    }

    // Inverse Hough Transform to visualize drawn edges
    function updateEdgePreview() {
      if (!userDrawnHoughData || !originalImg.complete) return;
      
      previewCtx.clearRect(0, 0, width, height);
      
      // Create a temporary canvas for the Hough space
      const houghCanvas = document.createElement('canvas');
      houghCanvas.width = userDrawnHoughData.width;
      houghCanvas.height = userDrawnHoughData.height;
      const houghCtx = houghCanvas.getContext('2d');
      houghCtx.putImageData(userDrawnHoughData, 0, 0);
      
      // Get the Hough space data
      const houghData = houghCtx.getImageData(0, 0, houghCanvas.width, houghCanvas.height);
      const houghWidth = houghCanvas.width;
      const houghHeight = houghCanvas.height;
      
      // Parameters for Hough transform
      const maxDist = Math.sqrt(width*width + height*height) / 2;
      const thetaSteps = houghWidth;
      const rhoSteps = houghHeight;
      const dTheta = Math.PI / thetaSteps;
      
      // Create a buffer for the edge image
      const edgeBuffer = new Uint8ClampedArray(width * height);
      
      // For each point in Hough space, draw the corresponding line in image space
      for (let thetaIdx = 0; thetaIdx < thetaSteps; thetaIdx++) {
        for (let rhoIdx = 0; rhoIdx < rhoSteps; rhoIdx++) {
          const idx = (rhoIdx * thetaSteps + thetaIdx) * 4;
          const intensity = houghData.data[idx]; // Using red channel
          
          if (intensity > 10) { // Only consider significant votes
            const theta = thetaIdx * dTheta;
            const rho = (rhoIdx / rhoSteps) * 2 * maxDist - maxDist;
            
            // Convert polar to cartesian
            const cosTheta = Math.cos(theta);
            const sinTheta = Math.sin(theta);
            
            // Draw the line in image space
            if (Math.abs(sinTheta) > Math.abs(cosTheta)) {
              // More vertical line
              for (let y = 0; y < height; y++) {
                const x = Math.round((rho - y * sinTheta) / cosTheta);
                if (x >= 0 && x < width) {
                  edgeBuffer[y * width + x] = Math.min(255, edgeBuffer[y * width + x] + intensity);
                }
              }
            } else {
              // More horizontal line
              for (let x = 0; x < width; x++) {
                const y = Math.round((rho - x * cosTheta) / sinTheta);
                if (y >= 0 && y < height) {
                  edgeBuffer[y * width + x] = Math.min(255, edgeBuffer[y * width + x] + intensity);
                }
              }
            }
          }
        }
      }
      
      // Create image data from the edge buffer
      const edgeImgData = previewCtx.createImageData(width, height);
      for (let i = 0; i < edgeBuffer.length; i++) {
        const val = Math.min(255, edgeBuffer[i]);
        edgeImgData.data[i*4] = 255; // Red
        edgeImgData.data[i*4+1] = 0;
        edgeImgData.data[i*4+2] = 0;
        edgeImgData.data[i*4+3] = val; // Alpha based on intensity
      }
      
      previewCtx.putImageData(edgeImgData, 0, 0);
    }

    // Function to find peaks in Hough space
  function findHoughPeaks(houghData, threshold = 100, minDistance = 10) {
    const peaks = [];
    const width = houghData.width;
    const height = houghData.height;
    const data = houghData.data;
    
    for (let y = minDistance; y < height - minDistance; y++) {
      for (let x = minDistance; x < width - minDistance; x++) {
        const idx = (y * width + x) * 4;
        const intensity = data[idx]; // Red channel
        
        if (intensity > threshold) {
          // Check if this is a local maximum
          let isLocalMax = true;
          for (let dy = -minDistance; dy <= minDistance && isLocalMax; dy++) {
            for (let dx = -minDistance; dx <= minDistance && isLocalMax; dx++) {
              if (dx === 0 && dy === 0) continue;
              const neighborIdx = ((y + dy) * width + (x + dx)) * 4;
              if (data[neighborIdx] >= intensity) {
                isLocalMax = false;
              }
            }
          }
          
          if (isLocalMax) {
            peaks.push({ x, y, intensity });
          }
        }
      }
    }
    
    // Sort by intensity (strongest peaks first)
    peaks.sort((a, b) => b.intensity - a.intensity);
    return peaks.slice(0, 20); // Return top 20 peaks
  }

  // Function to draw detected lines on the preview overlay
  function drawDetectedLines() {
    if (!originalHoughData) return;
    
    previewCtx.clearRect(0, 0, width, height);
    
    // Find peaks in the original Hough space
    const peaks = findHoughPeaks(originalHoughData, 50, 5);
    
    if (peaks.length === 0) {
      console.log("No peaks found in Hough space");
      return;
    }
    
    console.log(`Found ${peaks.length} peaks`);
    
    // Parameters for Hough transform
    const houghWidth = originalHoughData.width;
    const houghHeight = originalHoughData.height;
    const maxDist = Math.sqrt(width * width + height * height) / 2;
    const dTheta = Math.PI / houghWidth;
    
    // Set up drawing style
    previewCtx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
    previewCtx.lineWidth = 2;
    
    // Draw each detected line
    peaks.forEach((peak, index) => {
      const theta = peak.x * dTheta;
      const rho = (peak.y / houghHeight) * 2 * maxDist - maxDist;
      
      const cosTheta = Math.cos(theta);
      const sinTheta = Math.sin(theta);
      
      // Calculate line endpoints
      let x1, y1, x2, y2;
      
      if (Math.abs(sinTheta) > Math.abs(cosTheta)) {
        // More vertical line
        y1 = 0;
        y2 = height - 1;
        x1 = (rho - y1 * sinTheta) / cosTheta;
        x2 = (rho - y2 * sinTheta) / cosTheta;
      } else {
        // More horizontal line
        x1 = 0;
        x2 = width - 1;
        y1 = (rho - x1 * cosTheta) / sinTheta;
        y2 = (rho - x2 * cosTheta) / sinTheta;
      }
      
      // Only draw if line intersects the image
      if ((x1 >= 0 && x1 < width) || (x2 >= 0 && x2 < width) || 
          (y1 >= 0 && y1 < height) || (y2 >= 0 && y2 < height)) {
        
        // Clip line to image boundaries
        const clipped = clipLineToRect(x1, y1, x2, y2, 0, 0, width, height);
        if (clipped) {
          previewCtx.beginPath();
          previewCtx.moveTo(clipped.x1, clipped.y1);
          previewCtx.lineTo(clipped.x2, clipped.y2);
          previewCtx.stroke();
        }
      }
    });
  }

  // Helper function to clip line to rectangle
  function clipLineToRect(x1, y1, x2, y2, rectX, rectY, rectWidth, rectHeight) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    
    let t1 = 0, t2 = 1;
    
    const clipTest = (p, q) => {
      if (p === 0) return q >= 0;
      const t = q / p;
      if (p < 0) {
        if (t > t2) return false;
        if (t > t1) t1 = t;
      } else {
        if (t < t1) return false;
        if (t < t2) t2 = t;
      }
      return true;
    };
    
    if (clipTest(-dx, x1 - rectX) &&
        clipTest(dx, (rectX + rectWidth) - x1) &&
        clipTest(-dy, y1 - rectY) &&
        clipTest(dy, (rectY + rectHeight) - y1)) {
      
      return {
        x1: x1 + t1 * dx,
        y1: y1 + t1 * dy,
        x2: x1 + t2 * dx,
        y2: y1 + t2 * dy
      };
    }
    
    return null;
  }

    

    // --- Search against server ---
    async function findMostSimilarImage(){
      if(!userDrawnHoughData){
        matchInfo.textContent="Please draw on the Hough space first.";
        return;
      }
      const w=userDrawnHoughData.width, h=userDrawnHoughData.height;
      const arr=[];
      for(let y=0;y<h;y++){
        const row=[];
        for(let x=0;x<w;x++){
          row.push(userDrawnHoughData.data[(y*w+x)*4]);
        }
        arr.push(row);
      }

      matchInfo.textContent="Searching server for similar images...";
      findSimilarBtn.disabled=true;
      try{
        const resp=await fetch('http://localhost:5000/search',{
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body:JSON.stringify({hough_data:arr, top_k:10, use_embeddings:true})
        });
        if(!resp.ok) throw new Error(`${resp.status} ${resp.statusText}`);
        const data=await resp.json();
        displayServerResults(data);
      }catch(err){
        matchInfo.textContent=`Search failed: ${err.message}`;
      }finally{
        findSimilarBtn.disabled=false;
      }
    }

    function displayServerResults(data){
      if(!data.results?.length){
        matchInfo.innerHTML="No similar images found.";
        return;
      }
      let html=`<strong>Search complete!</strong><br>`;
      html+=`Top ${data.results.length} matches (time: ${data.search_time_ms} ms):<ul>`;
      data.results.forEach((r, i) => {
        // convert angular distance (0=identical, up to ~2) into a 0‚Äì100% similarity
        const similarityPct = ((1 - r.distance) * 100).toFixed(2);
        html += `<li><strong>#${i+1}</strong>: ${r.key} ‚Äî Similarity: ${similarityPct}%<br>`;
        html += `File: ${r.file}<br>Path: ${r.path}</li>`;
      });
      html+="</ul>";
      matchInfo.innerHTML=html;

      // load top match
      const topKey=data.results[0].key;
      currentKey=topKey;
      if(!(topKey in allData)) return;
      const entry=allData[topKey];
      originalImg=new Image();
      originalImg.crossOrigin="Anonymous";
      originalImg.onload=()=>drawStep(parseInt(stepSlider.value));
      originalImg.src=entry.path;
      if(entry.hough_sinusoids){
        const dec=decodeArrayToUint8ClampedArray(entry.hough_sinusoids);
        originalHoughData=toImageDataFromGray(dec.data,dec.width,dec.height);
        initializeUserDrawnHough();
        redrawHoughCanvas();
      }
    }

    // --- Loading JSON files locally ---
    async function discoverJsonFiles(){
      const folder='json_minimal_edges_base64/';
      const files=[
        'Abstract_Expressionism_part1.json',
        'Action_painting_part1.json',
        'Analytical_Cubism_part1.json',
        'Art_Nouveau_Modern_part1.json',
        'Art_Nouveau_Modern_part2.json',
        'Baroque_part1.json',
        'Baroque_part2.json',
        'Color_Field_Painting_part1.json',
        'Contemporary_Realism_part1.json',
        'Cubism_part1.json',
        'Early_Renaissance_part1.json',
        'Expressionism_part1.json',
        'Expressionism_part2.json',
        'Fauvism_part1.json',
        'High_Renaissance_part1.json',
        'Impressionism_part1.json',
        'Impressionism_part2.json',
        'Impressionism_part3.json',
        'Impressionism_part4.json',
        'Impressionism_part5.json',
        'Mannerism_Late_Renaissance_part1.json',
        'Minimalism_part1.json',
        'Naive_Art_Primitivism_part1.json',
        'New_Realism_part1.json',
        'Northern_Renaissance_part1.json',
        'Northern_Renaissance_part2.json',
        'Pointillism_part1.json',
        'Pop_Art_part1.json',
        'Post_Impressionism_part1.json',
        'Post_Impressionism_part2.json',
        'Post_Impressionism_part3.json',
        'Realism_part1.json',
        'Realism_part2.json',
        'Realism_part3.json',
        'Rococo_part1.json',
        'Romanticism_part1.json',
        'Romanticism_part2.json',
        'Romanticism_part3.json',
        'Symbolism_part1.json',
        'Symbolism_part2.json',
        'Synthetic_Cubism_part1.json',
        'Ukiyo_e_part1.json'
      ];
      return files.map(f=>folder+f);
    }

    async function loadAllJsonFiles(){
      loadingStatus.textContent="Discovering JSON files‚Ä¶";
      const paths=await discoverJsonFiles();
      let count=0, total=0;
      for(const p of paths){
        try{
          loadingStatus.textContent=`Loading ${p}‚Ä¶ (${count} files, ${total} images)`;
          const res=await fetch(p);
          if(!res.ok){ console.log(`Skipped ${p}`); continue; }
          const data=await res.json();
          Object.assign(allData,data);
          count++; total+=Object.keys(data).length;
          loadingStatus.innerHTML=`
            <strong>Progress:</strong> ${count} files<br>
            <strong>Total Images:</strong> ${total}<br>
            <strong>Latest:</strong> ${p.split('/').pop()}
          `;
          await new Promise(r=>setTimeout(r,50));
        }catch(e){
          console.log(`Error loading ${p}: ${e}`);
        }
      }
      dataKeys=Object.keys(allData);
      if(total>0){
        loadingStatus.innerHTML=`
          <strong>‚úì Loading Complete!</strong><br>
          <strong>Files:</strong> ${count}<br>
          <strong>Total Images:</strong> ${total}<br>
          <strong>Ready for similarity search</strong>
        `;
        loadRandomImage();
      } else {
        loadingStatus.innerHTML="<strong>‚ö†Ô∏è No JSON files found</strong>";
      }
    }

    function loadRandomImage(){
      if(!dataKeys.length) return;
      currentKey=dataKeys[Math.floor(Math.random()*dataKeys.length)];
      const e=allData[currentKey];
      stepSlider.value=0;
      stepLabel.textContent='Step: original';
      originalImg=new Image();
      originalImg.crossOrigin="Anonymous";
      originalImg.onload=()=>{
        drawStep(0);
        processImageSteps();
        redrawHoughCanvas();
      };
      originalImg.onerror=()=>{
        ctx.clearRect(0,0,width,height);
        houghCtx.clearRect(0,0,width,height);
      };
      originalImg.src=e.path;

      const dec=decodeArrayToUint8ClampedArray(e.edges_downscaled);
      edgesDownscaledImgData=toImageDataFromGray(dec.data,dec.width,dec.height);

      if(e.hough_sinusoids){
        const hdec=decodeArrayToUint8ClampedArray(e.hough_sinusoids);
        houghImgData=toImageDataFromGray(hdec.data,hdec.width,hdec.height);
        originalHoughData=houghImgData;
        initializeUserDrawnHough();
      }
      matchInfo.innerHTML=`
        <strong>Current Image:</strong> ${currentKey}<br>
        <strong>Dataset Size:</strong> ${dataKeys.length} images<br>
        Draw on the Hough space and click 'Find Most Similar Image'
      `;
    }

    function processImageSteps(){
      ctx.clearRect(0,0,width,height);
      ctx.drawImage(originalImg,0,0,width,height);
      const img=ctx.getImageData(0,0,width,height);
      grayImageData=toImageDataFromGray(rgbToGrayscale(img),width,height);
      const {Ix,Iy}=sobelFilter(rgbToGrayscale(img),width,height);
      gradientMagnitudeData=toImageDataFromGray(gradientMagnitude(Ix,Iy),width,height);
      const nms=nonMaximaSuppression(gradientMagnitude(Ix,Iy),gradientAngle(Ix,Iy),width,height);
      nonmaxSuppressionData=toImageDataFromGray(nms,width,height);
      hysteresisData=toImageDataFromGray(hysteresisThreshold(nms,width,height),width,height);
    }

    function drawStep(idx){
      ctx.clearRect(0,0,width,height);
      switch(PROCESSING_STEPS[idx]){
        case 'original':
          if(originalImg.complete) ctx.drawImage(originalImg,0,0,width,height);
          break;
        case 'grayscale':
          if(grayImageData) ctx.putImageData(grayImageData,0,0);
          break;
        case 'gradient_magnitude':
          if(gradientMagnitudeData) ctx.putImageData(gradientMagnitudeData,0,0);
          break;
        case 'nonmaxima':
          if(nonmaxSuppressionData) ctx.putImageData(nonmaxSuppressionData,0,0);
          break;
        case 'hysteresis':
          if(hysteresisData) ctx.putImageData(hysteresisData,0,0);
          break;
        case 'canny_downscaled':
          if(edgesDownscaledImgData){
            const off=document.createElement('canvas');
            off.width=edgesDownscaledImgData.width;
            off.height=edgesDownscaledImgData.height;
            off.getContext('2d').putImageData(edgesDownscaledImgData,0,0);
            ctx.imageSmoothingEnabled=false;
            ctx.drawImage(off,0,0,width,height);
            ctx.imageSmoothingEnabled=true;
          }
          break;
      }
    }

    function updateDrawingModeIndicator() {
      const modeIndicator = document.getElementById('active-mode');
      const modeText = document.getElementById('draw-mode');
      
      if (drawingEnabled) {
        modeIndicator.classList.add('visible');
        modeText.textContent = drawingMode === 'hough' ? 'Hough Space' : 'Image';
      } else {
        modeIndicator.classList.remove('visible');
      }
    }

    // --- Event listeners ---
    stepSlider.addEventListener('input',e=>{
      const v=parseInt(e.target.value);
      stepLabel.textContent=`Step: ${PROCESSING_STEPS[v]}`;
      drawStep(v);
    });
    randomBtn.addEventListener('click', (e) => {
      console.log('Random button clicked');
      loadRandomImage();
    });
    toggleDrawBtn.addEventListener('click', () => {
      drawingEnabled = !drawingEnabled;
      toggleDrawBtn.textContent = drawingEnabled ? '‚úèÔ∏è Disable Drawing' : '‚úèÔ∏è Enable Drawing';
      toggleDrawBtn.classList.toggle('active', drawingEnabled);
      houghCanvas.classList.toggle('drawing', drawingEnabled && drawingMode === 'hough');
      canvas.classList.toggle('drawing', drawingEnabled && drawingMode === 'image');
      
      if(drawingEnabled) {
        if(drawingMode === 'hough') {
          initializeUserDrawnHough();
        } else {
          initializeImageDrawing();
        }
      }
      redrawHoughCanvas();
      updateDrawingModeIndicator();
    });
    clearHoughBtn.addEventListener('click', () => {
      if(drawingMode === 'hough') {
        initializeUserDrawnHough();
      } else {
        initializeImageDrawing();
        previewCtx.clearRect(0, 0, width, height);
      }
      redrawHoughCanvas();
      matchInfo.textContent = "Drawing cleared. Draw and click 'Find Most Similar'";
    });
    brushSizeSlider.addEventListener('input',e=>brushSizeLabel.textContent=e.target.value);
    brushIntensitySlider.addEventListener('input',e=>brushIntensityLabel.textContent=e.target.value);
    findSimilarBtn.addEventListener('click',findMostSimilarImage);
    showPreviewBtn.addEventListener('click',()=>{
      showPreview = !showPreview;
      showPreviewBtn.textContent = showPreview ? 'Hide Edge Preview' : 'Show Edge Preview';
      showPreviewBtn.classList.toggle('active', showPreview);
      if (showPreview) {
        updateEdgePreview();
      } else {
        previewCtx.clearRect(0, 0, width, height);
      }
    });
    toggleDrawModeBtn.addEventListener('click', () => {
      drawingMode = drawingMode === 'hough' ? 'image' : 'hough';
      toggleDrawModeBtn.textContent = drawingMode === 'hough' ? 'üîÑ Draw on Image' : 'üîÑ Draw on Hough';
      toggleDrawModeBtn.classList.toggle('active', drawingMode === 'image');
      
      houghCanvas.classList.toggle('drawing', drawingEnabled && drawingMode === 'hough');
      canvas.classList.toggle('drawing', drawingEnabled && drawingMode === 'image');
      
      if(drawingMode === 'image') {
        initializeImageDrawing();
      }
      updateDrawingModeIndicator();
    });
    houghCanvas.addEventListener('mousedown',e=>{
      if(!drawingEnabled) return;
      isDrawing=true;
      const r=houghCanvas.getBoundingClientRect();
      drawOnHough(e.clientX-r.left,e.clientY-r.top);
    });
    houghCanvas.addEventListener('mousemove',e=>{
      if(drawingEnabled && isDrawing){
        const r=houghCanvas.getBoundingClientRect();
        drawOnHough(e.clientX-r.left,e.clientY-r.top);
      }
    });
    ['mouseup','mouseleave'].forEach(evt=>{
      houghCanvas.addEventListener(evt,()=> isDrawing=false);
    });
    canvas.addEventListener('mousedown', e => {
      if(!drawingEnabled || drawingMode !== 'image') return;
      isDrawing = true;
      const r = canvas.getBoundingClientRect();
      drawOnImage(e.clientX - r.left, e.clientY - r.top);
    });
    canvas.addEventListener('mousemove', e => {
      if(drawingEnabled && isDrawing && drawingMode === 'image') {
        const r = canvas.getBoundingClientRect();
        drawOnImage(e.clientX - r.left, e.clientY - r.top);
      }
    });
    ['mouseup', 'mouseleave'].forEach(evt => {
      canvas.addEventListener(evt, () => isDrawing = false);
    });

    // Modal functionality
    aboutMethodsBtn.addEventListener('click', () => {
      methodsModal.classList.add('active');
    });

    modalCloseBtn.addEventListener('click', () => {
      methodsModal.classList.remove('active');
    });

    methodsModal.addEventListener('click', (e) => {
      if (e.target === methodsModal) {
        methodsModal.classList.remove('active');
      }
    });

    showDetectedLinesBtn.addEventListener('click', () => {
    showDetectedLines = !showDetectedLines;
    showDetectedLinesBtn.textContent = showDetectedLines ? 'üìè Hide Detected Lines' : 'üìè Show Detected Lines';
    showDetectedLinesBtn.classList.toggle('active', showDetectedLines);
    
    if (showDetectedLines) {
      drawDetectedLines();
    } else {
      previewCtx.clearRect(0, 0, width, height);
      // If edge preview is also active, redraw it
      if (showPreview) {
        updateEdgePreview();
      }
    }
  });

    // --- Poll server readiness ---
    findSimilarBtn.disabled = true;
    async function checkServerReady(){
      try{
        const res=await fetch('http://localhost:5000/status');
        if(!res.ok) throw new Error(res.statusText);
        const {loading_complete} = await res.json();
        if(loading_complete){
          loadingStatus.textContent = '‚úì Server ready for similarity search';
          findSimilarBtn.disabled = false;
          clearInterval(statusInterval);
        } else {
          loadingStatus.textContent = 'Computing embeddings, please wait‚Ä¶';
        }
      }catch(err){
        loadingStatus.textContent = `Error checking server status: ${err.message}`;
      }
    }
    const statusInterval = setInterval(checkServerReady,2000);
    checkServerReady();

    // --- Initialize data loading ---
    loadAllJsonFiles();
  });
  </script>
</body>
</html>